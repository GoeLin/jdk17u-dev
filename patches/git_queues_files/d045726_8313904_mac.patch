diff --git a/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacAppImageBuilder.java b/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacAppImageBuilder.java
index cd21c8110a3..5498f9ac77c 100644
--- a/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacAppImageBuilder.java
+++ b/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacAppImageBuilder.java
@@ -690,7 +690,7 @@ public class MacAppImageBuilder extends AbstractAppImageBuilder {
         return args;
     }
 
-    private static void signAppBundle(
+    static void signAppBundle(
             Map<String, ? super Object> params, Path appLocation,
             String signingIdentity, String identifierPrefix, Path entitlements)
             throws IOException {
diff --git a/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacBaseInstallerBundler.java b/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacBaseInstallerBundler.java
index 77677369a17..9c920e2d6fa 100644
--- a/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacBaseInstallerBundler.java
+++ b/src/jdk.jpackage/macosx/classes/jdk/jpackage/internal/MacBaseInstallerBundler.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2014, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2014, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -154,18 +154,52 @@ public abstract class MacBaseInstallerBundler extends AbstractBundler {
             appImageBundler.validate(params);
         }
     }
-
+    /*
     protected Path prepareAppBundle(Map<String, ? super Object> params)
             throws PackagerException {
         Path predefinedImage =
                 StandardBundlerParam.getPredefinedAppImage(params);
         if (predefinedImage != null) {
             return predefinedImage;
+            /*
+            GLGL TBD
+                // We need to re-sign app image after adding ".package" to it.
+                // We only do this if app image was not signed which means it is
+                // signed with ad-hoc signature. App bundles with ad-hoc
+                // signature are sealed, but without a signing identity, so we
+                // need to re-sign it after modification.
+                MacAppImageBuilder.signAppBundle(params, appDir, "-", null, null);
+            *
         }
         Path appImageRoot = APP_IMAGE_TEMP_ROOT.fetchFrom(params);
 
         return appImageBundler.execute(params, appImageRoot);
     }
+    */
+    protected Path prepareAppBundle(Map<String, ? super Object> params)
+            throws PackagerException {
+        Path appDir;
+        Path appImageRoot = APP_IMAGE_TEMP_ROOT.fetchFrom(params);
+        Path predefinedImage =
+                StandardBundlerParam.getPredefinedAppImage(params);
+        if (predefinedImage != null) {
+            appDir = predefinedImage;
+            // Create PackageFile if predefined app image is not signed
+            if (!StandardBundlerParam.isRuntimeInstaller(params) &&
+                    !AppImageFile.load(predefinedImage).isSigned()) {
+                // We need to re-sign app image after adding ".package" to it.
+                // We only do this if app image was not signed which means it is
+                // signed with ad-hoc signature. App bundles with ad-hoc
+                // signature are sealed, but without a signing identity, so we
+                // need to re-sign it after modification.
+                MacAppImageBuilder.signAppBundle(params, appDir, "-", null, null);
+            }
+        } else {
+            appDir = appImageBundler.execute(params, appImageRoot);
+        }
+
+        return appDir;
+    }
 
     @Override
     public String getBundleType() {
diff --git a/test/jdk/tools/jpackage/macosx/SigningPackageTest.java b/test/jdk/tools/jpackage/macosx/SigningPackageTest.java
index 351e354357b..5a057af3d3c 100644
--- a/test/jdk/tools/jpackage/macosx/SigningPackageTest.java
+++ b/test/jdk/tools/jpackage/macosx/SigningPackageTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -70,7 +70,7 @@ public class SigningPackageTest {
 
     private static void verifyDMG(JPackageCommand cmd) {
         Path outputBundle = cmd.outputBundle();
-        SigningBase.verifyCodesign(outputBundle, false);
+        SigningBase.verifyDMG(outputBundle);
     }
 
     private static void verifyAppImageInDMG(JPackageCommand cmd) {
diff --git a/test/jdk/tools/jpackage/macosx/SigningPackageTwoStepTest.java b/test/jdk/tools/jpackage/macosx/SigningPackageTwoStepTest.java
new file mode 100644
index 00000000000..f0442f92af4
--- /dev/null
+++ b/test/jdk/tools/jpackage/macosx/SigningPackageTwoStepTest.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2022, 2023, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+import java.nio.file.Path;
+import jdk.jpackage.internal.ApplicationLayout;
+import jdk.jpackage.test.JPackageCommand;
+import jdk.jpackage.test.TKit;
+import jdk.jpackage.test.PackageTest;
+import jdk.jpackage.test.PackageType;
+import jdk.jpackage.test.MacHelper;
+import jdk.jpackage.test.Annotations.Test;
+import jdk.jpackage.test.Annotations.Parameter;
+
+/**
+ * Note: Testing unsgined app image is done to verify support for per-user
+ * configuration by checking for PackageFile.
+ * Tests generation of dmg and pkg from signed or unsigned predefined app image.
+ * Test will generate pkg and verifies its signature. It verifies that dmg
+ * is not signed, but app image inside dmg is signed or unsigned. This test
+ * requires that the machine is configured with test certificate for
+ * "Developer ID Installer: jpackage.openjdk.java.net" in
+ * jpackagerTest keychain with
+ * always allowed access to this keychain for user which runs test.
+ * note:
+ * "jpackage.openjdk.java.net" can be over-ridden by systerm property
+ * "jpackage.mac.signing.key.user.name", and
+ * "jpackagerTest" can be over-ridden by system property
+ * "jpackage.mac.signing.keychain"
+ */
+
+/*
+ * @test
+ * @summary jpackage with --type pkg,dmg --app-image
+ * @library ../helpers
+ * @library /test/lib
+ * @library base
+ * @key jpackagePlatformPackage
+ * @build SigningBase
+ * @build SigningCheck
+ * @build jtreg.SkippedException
+ * @build jdk.jpackage.test.*
+ * @build SigningPackageTwoStepTest
+ * @modules jdk.jpackage/jdk.jpackage.internal
+ * @requires (os.family == "mac")
+ * @run main/othervm/timeout=720 -Xmx512m jdk.jpackage.test.Main
+ *  --jpt-run=SigningPackageTwoStepTest
+ */
+public class SigningPackageTwoStepTest {
+
+    private static void verifyPKG(JPackageCommand cmd) {
+        if (!cmd.hasArgument("--mac-sign")) {
+            return; // Nothing to check if not signed
+        }
+
+        Path outputBundle = cmd.outputBundle();
+        SigningBase.verifyPkgutil(outputBundle);
+        SigningBase.verifySpctl(outputBundle, "install");
+    }
+
+    private static void verifyDMG(JPackageCommand cmd) {
+        // DMG always unsigned, so we will check it
+        Path outputBundle = cmd.outputBundle();
+        SigningBase.verifyDMG(outputBundle);
+    }
+
+    private static void verifyAppImageInDMG(JPackageCommand cmd) {
+        MacHelper.withExplodedDmg(cmd, dmgImage -> {
+            // We will be called with all folders in DMG since JDK-8263155, but
+            // we only need to verify app.
+            if (dmgImage.endsWith(cmd.name() + ".app")) {
+                boolean isSigned = cmd.hasArgument("--mac-sign");
+                Path launcherPath = ApplicationLayout.platformAppImage()
+                    .resolveAt(dmgImage).launchersDirectory().resolve(cmd.name());
+                SigningBase.verifyCodesign(launcherPath, isSigned);
+                SigningBase.verifyCodesign(dmgImage, isSigned);
+                if (isSigned) {
+                    SigningBase.verifySpctl(dmgImage, "exec");
+                }
+            }
+        });
+    }
+
+    @Test
+    @Parameter("true")
+    @Parameter("false")
+    public static void test(boolean signAppImage) throws Exception {
+        SigningCheck.checkCertificates();
+
+        Path appimageOutput = TKit.createTempDirectory("appimage");
+
+        JPackageCommand appImageCmd = JPackageCommand.helloAppImage()
+                .setArgumentValue("--dest", appimageOutput);
+        if (signAppImage) {
+            appImageCmd.addArguments("--mac-sign")
+                    .addArguments("--mac-signing-key-user-name",
+                            SigningBase.DEV_NAME)
+                    .addArguments("--mac-signing-keychain",
+                            SigningBase.KEYCHAIN);
+        }
+
+        new PackageTest()
+                .addRunOnceInitializer(() -> appImageCmd.execute())
+                .forTypes(PackageType.MAC)
+                .addInitializer(cmd -> {
+                    cmd.addArguments("--app-image", appImageCmd.outputBundle());
+                    cmd.removeArgumentWithValue("--input");
+                    if (signAppImage) {
+                        cmd.addArguments("--mac-sign",
+                                "--mac-signing-key-user-name",
+                                SigningBase.DEV_NAME,
+                                "--mac-signing-keychain",
+                                SigningBase.KEYCHAIN);
+                    }
+                })
+                .forTypes(PackageType.MAC_PKG)
+                .addBundleVerifier(SigningPackageTwoStepTest::verifyPKG)
+                .forTypes(PackageType.MAC_DMG)
+                .addBundleVerifier(SigningPackageTwoStepTest::verifyDMG)
+                .addBundleVerifier(SigningPackageTwoStepTest::verifyAppImageInDMG)
+                .run();
+    }
+}
diff --git a/test/jdk/tools/jpackage/macosx/base/SigningBase.java b/test/jdk/tools/jpackage/macosx/base/SigningBase.java
index 9c7f7f21851..fc9024ee109 100644
--- a/test/jdk/tools/jpackage/macosx/base/SigningBase.java
+++ b/test/jdk/tools/jpackage/macosx/base/SigningBase.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2019, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -43,35 +43,67 @@ public class SigningBase {
         KEYCHAIN = (value == null) ? "jpackagerTest.keychain" : value;
     }
 
+    // Note: It is not clear if we can combine "--verify" and "--display", so
+    // we testing them separately. Since JDK-8298488 unsigned app images are
+    // actually signed with adhoc signature and it will pass "--verify", so in
+    // addition we will check certificate name which was used to sign.
+    private static enum CodesignCheckType {
+        VERIFY, // Runs codesign with "--verify" to check signature and 0 exit code
+        VERIFY_UNSIGNED, // Runs codesign with "--verify" to check signature and 1 exit code
+        DISPLAY // Runs codesign with "--display --verbose=4" to get info about signature
+    };
+
     private static void checkString(List<String> result, String lookupString) {
         TKit.assertTextStream(lookupString).predicate(
                 (line, what) -> line.trim().contains(what)).apply(result.stream());
     }
 
-    private static List<String> codesignResult(Path target, boolean signed) {
-        int exitCode = signed ? 0 : 1;
-        List<String> result = new Executor()
-                .setExecutable("/usr/bin/codesign")
-                .addArguments("--verify", "--deep", "--strict", "--verbose=2",
-                        target.toString())
-                .saveOutput()
-                .execute(exitCode).getOutput();
-
-        return result;
+    private static List<String> codesignResult(Path target, CodesignCheckType type) {
+        int exitCode = 0;
+        Executor executor = new Executor().setExecutable("/usr/bin/codesign");
+        switch (type) {
+            case CodesignCheckType.VERIFY_UNSIGNED:
+                exitCode = 1;
+            case CodesignCheckType.VERIFY:
+                executor.addArguments("--verify", "--deep", "--strict",
+                                      "--verbose=2", target.toString());
+                break;
+            case CodesignCheckType.DISPLAY:
+                executor.addArguments("--display", "--verbose=4", target.toString());
+                break;
+            default:
+                TKit.error("Unknown CodesignCheckType: " + type);
+                break;
+        }
+        return executor.saveOutput().execute(exitCode).getOutput();
     }
 
     private static void verifyCodesignResult(List<String> result, Path target,
-            boolean signed) {
+            boolean signed, CodesignCheckType type) {
         result.stream().forEachOrdered(TKit::trace);
-        if (signed) {
-            String lookupString = target.toString() + ": valid on disk";
-            checkString(result, lookupString);
-            lookupString = target.toString() + ": satisfies its Designated Requirement";
-            checkString(result, lookupString);
-        } else {
-            String lookupString = target.toString()
-                    + ": code object is not signed at all";
-            checkString(result, lookupString);
+        String lookupString;
+        switch (type) {
+            case CodesignCheckType.VERIFY:
+                lookupString = target.toString() + ": valid on disk";
+                checkString(result, lookupString);
+                lookupString = target.toString() + ": satisfies its Designated Requirement";
+                checkString(result, lookupString);
+                break;
+            case CodesignCheckType.VERIFY_UNSIGNED:
+                lookupString = target.toString() + ": code object is not signed at all";
+                checkString(result, lookupString);
+                break;
+            case CodesignCheckType.DISPLAY:
+                if (signed) {
+                    lookupString = "Authority=" + APP_CERT;
+                } else {
+                    lookupString = "Signature=adhoc";
+                }
+                checkString(result, lookupString);
+                break;
+            default:
+                TKit.error("Unknown CodesignCheckType: " + type);
+                break;
         }
     }
 
@@ -131,8 +163,24 @@ public class SigningBase {
     }
 
     public static void verifyCodesign(Path target, boolean signed) {
-        List<String> result = codesignResult(target, signed);
-        verifyCodesignResult(result, target, signed);
+        List<String> result = codesignResult(target, CodesignCheckType.VERIFY);
+        verifyCodesignResult(result, target, signed, CodesignCheckType.VERIFY);
+
+        result = codesignResult(target, CodesignCheckType.DISPLAY);
+        verifyCodesignResult(result, target, signed, CodesignCheckType.DISPLAY);
+    }
+
+    // Since we no longer have unsigned app image, but we need to check
+    // DMG which is not adhoc or certificate signed and we cannot use verifyCodesign
+    // for this. verifyDMG() is introduced to check that DMG is unsigned.
+    // Should not be used to validated anything else.
+    public static void verifyDMG(Path target) {
+        if (!target.toString().toLowerCase().endsWith(".dmg")) {
+            TKit.error("Unexpected target: " + target);
+        }
+
+        List<String> result = codesignResult(target, CodesignCheckType.VERIFY_UNSIGNED);
+        verifyCodesignResult(result, target, false, CodesignCheckType.VERIFY_UNSIGNED);
     }
 
     public static void verifySpctl(Path target, String type) {
diff --git a/test/jdk/tools/jpackage/share/AppImagePackageTest.java b/test/jdk/tools/jpackage/share/AppImagePackageTest.java
index ae9f6a21ffc..8afc886b18f 100644
--- a/test/jdk/tools/jpackage/share/AppImagePackageTest.java
+++ b/test/jdk/tools/jpackage/share/AppImagePackageTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2018, 2021, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2018, 2023, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -93,7 +93,11 @@ public class AppImagePackageTest {
             if (TKit.isOSX()) {
                 cmd.addArguments("--mac-package-identifier", name);
             }
-        }).run(Action.CREATE, Action.UNPACK);
+        })
+        // On macOS we always signing app image and signing will fail, since
+        // test produces invalid app bundle.
+        .setExpectedExitCode(TKit.isOSX() ? 1 : 0)
+        .run(Action.CREATE, Action.UNPACK);
         // default: {CREATE, UNPACK, VERIFY}, but we can't verify foreign image
     }
 
